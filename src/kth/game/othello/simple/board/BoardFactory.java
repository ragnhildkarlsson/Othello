package kth.game.othello.simple.board;

import java.util.Set;

/**
 * A BoardFactory generates new {@link ImmutableBoard}.
 * 
 * @author Mikael Eriksson
 * 
 */
public class BoardFactory {

	private static final int DEFAULT_BOARD_SIZE = 8;
	private static final String DEFAULT_WHITE_PLAYER_ID = "white";
	private static final String DEFAULT_BLACK_PLAYER_ID = "black";
    private NodeObserver observer;

	/**
	 * Create a BoardFactory.
     * TODO describe observer
	 */
	public BoardFactory(NodeObserver observer) {
        this.observer = observer;
	}

	/**
	 * //TODO
	 * 
	 * @return
	 */
	public ImmutableBoard newDefaultStartingBoard() {
		// TODO implement
		// Old Implementation
		// List<Node> nodes = new ArrayList<Node>();
		// int higherMiddlePosition = DEFAULT_BOARD_SIZE / 2;
		// int lowerMiddlePosition = higherMiddlePosition - 1;
		//
		// for (int y = 0; y < DEFAULT_BOARD_SIZE; y++) {
		// for (int x = 0; x < DEFAULT_BOARD_SIZE; x++) {
		// ImmutableNode node;
		// // If we are in the middle of the board, set nodes to occupied
		// if ((y == higherMiddlePosition || y == lowerMiddlePosition)
		// && (x == higherMiddlePosition || x == lowerMiddlePosition)) {
		// if (y == x) { // set equally colored nodes diagonally to
		// // each other
		// node = new ImmutableNode(x, y, DEFAULT_WHITE_PLAYER_ID);
		// } else {
		// node = new ImmutableNode(x, y, DEFAULT_BLACK_PLAYER_ID);
		// }
		// } else {// else the node should be unmarked
		// node = new ImmutableNode(x, y, null);
		// }
		// nodes.add(node);
		// }
		// }
		// ImmutableBoard board = new ImmutableBoard(nodes);
		return null;
	}

	/**
	 * Generate a new board given an old Board, a list of nodes from the old
	 * board to swap, and the player ID to swap the nodes to.
	 * 
	 * @param oldBoard
	 *            The old board to swap nodes on
	 * @param nodesToSwap
	 *            Which nodes on the old board that should be swapped
	 * @param playerIDToSwapTo
	 *            player ID to set for the nodes that will be swapped
	 * @return a board with nodes swapped according to nodesToSwap
	 * @throws IllegalArgumentException
	 *             if the old board size is different from the board size
	 *             generated by this factory
	 */
	public ImmutableBoard newBoardReplacingNodesInBoard(ImmutableBoard oldBoard, Set<ImmutableNode> nodesToSwap,
			String playerIDToSwapTo) throws IllegalArgumentException {
		// TODO
		// Old implementation

		// if (oldBoard.getNodes().size() != DEFAULT_BOARD_SIZE *
		// DEFAULT_BOARD_SIZE) {
		// // TODO Remove dependency on board size
		// throw new
		// IllegalArgumentException("Cannot generate a new board based on differently sized old board.");
		// }
		// //
		// List<Node> nodes = new ArrayList<Node>();
		// for (int y = 0; y < DEFAULT_BOARD_SIZE; y++) {
		// for (int x = 0; x < DEFAULT_BOARD_SIZE; x++) {
		// // TODO do not create new nodes
		// // See if this node needs to be swapped
		// Node newNode;
		// Node tempNode = findNodeByCoordinates(nodesToSwap, x, y);
		// if (tempNode != null) { // this node should be swapped
		// newNode = new ImmutableNode(x, y, playerIDToSwapTo);
		// } else { // this node should remain the same as in old board
		// tempNode = findNodeByCoordinates(oldBoard.getNodes(), x, y);
		// newNode = new ImmutableNode(x, y, tempNode.getOccupantPlayerId());
		// }
		// nodes.add(newNode);
		// }
		// }
		// ImmutableBoard newBoard = new ImmutableBoard(nodes);

		return null;
	}

    public ImmutableBoard boardFromNodes(Set<ImmutableNode> nodes) {
        // TODO
    }

	//
	// private Node findNodeByCoordinates(List<Node> nodesToSearch, int
	// xCoordinate, int yCoordinate) {
	// for (Node node : nodesToSearch) {
	// if (node.getXCoordinate() == xCoordinate && node.getYCoordinate() ==
	// yCoordinate)
	// return node;
	// }
	// return null;
	// }
}
